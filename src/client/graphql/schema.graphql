type GraphQLApplicationError implements Error {
  message: String!
  path: [String]
  code: String
}

interface Error {
  message: String!
  path: [String]
  code: String
}

type ConsumerAccount implements Account {
  id: ID!
  wallets: [Wallet!]!
  defaultWalletId: WalletId!
  displayCurrency: DisplayCurrency!
  level: AccountLevel!
  realtimePrice: RealtimePrice!

  # return CSV stream, base64 encoded, of the list of transactions in the wallet
  csvTransactions(walletIds: [WalletId!]!): String!
  limits: AccountLimits!

  # List the quiz questions of the consumer account
  quiz: [Quiz!]!

  # A list of all transactions associated with walletIds optionally passed.
  transactions(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the first n items from the list.
    first: Int

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the last n items from the list.
    last: Int
    walletIds: [WalletId]
  ): TransactionConnection
}

interface Account {
  id: ID!
  wallets: [Wallet!]!
  defaultWalletId: WalletId!
  displayCurrency: DisplayCurrency!
  level: AccountLevel!
  realtimePrice: RealtimePrice!
  csvTransactions(walletIds: [WalletId!]!): String!
  limits: AccountLimits!
  transactions(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the first n items from the list.
    first: Int

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the last n items from the list.
    last: Int
    walletIds: [WalletId]
  ): TransactionConnection
}

# A generic wallet which stores value in one of our supported currencies.
interface Wallet {
  id: ID!
  accountId: ID!
  walletCurrency: WalletCurrency!
  balance: SignedAmount!
  pendingIncomingBalance: SignedAmount!

  # Transactions are ordered anti-chronologically,
  # ie: the newest transaction will be first
  transactions(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the first n items from the list.
    first: Int

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the last n items from the list.
    last: Int
  ): TransactionConnection

  # Transactions are ordered anti-chronologically,
  # ie: the newest transaction will be first
  transactionsByAddress(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the first n items from the list.
    first: Int

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the last n items from the list.
    last: Int

    # Returns the items that include this address.
    address: OnChainAddress!
  ): TransactionConnection
}

enum WalletCurrency {
  BTC
  USD
}

# An amount (of a currency) that can be negative (e.g. in a transaction)
scalar SignedAmount

# A connection to a list of items.
type TransactionConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # A list of edges.
  edges: [TransactionEdge!]
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String
}

# An edge in a connection.
type TransactionEdge {
  # The item at the end of the edge
  node: Transaction!

  # A cursor for use in pagination
  cursor: String!
}

# Give details about an individual transaction.
# Galoy have a smart routing system which is automatically
# settling intraledger when both the payer and payee use the same wallet
# therefore it's possible the transactions is being initiated onchain
# or with lightning but settled intraledger.
type Transaction {
  id: ID!

  # From which protocol the payment has been initiated.
  initiationVia: InitiationVia!

  # To which protocol the payment has settled on.
  settlementVia: SettlementVia!

  # Amount of the settlement currency sent or received.
  settlementAmount: SignedAmount!
  settlementFee: SignedAmount!

  # Price in WALLETCURRENCY/SETTLEMENTUNIT at time of settlement.
  settlementPrice: PriceOfOneSettlementMinorUnitInDisplayMinorUnit!

  # Wallet currency for transaction.
  settlementCurrency: WalletCurrency!
  settlementDisplayAmount: SignedDisplayMajorAmount!
  settlementDisplayFee: SignedDisplayMajorAmount!
  settlementDisplayCurrency: DisplayCurrency!
  direction: TxDirection!
  status: TxStatus!
  memo: Memo
  createdAt: Timestamp!
}

union InitiationVia =
    InitiationViaIntraLedger
  | InitiationViaLn
  | InitiationViaOnChain

type InitiationViaIntraLedger {
  counterPartyWalletId: WalletId
  counterPartyUsername: Username
}

# Unique identifier of a wallet
scalar WalletId

# Unique identifier of a user
scalar Username

type InitiationViaLn {
  paymentHash: PaymentHash!
}

scalar PaymentHash

type InitiationViaOnChain {
  address: OnChainAddress!
}

# An address for an on-chain bitcoin destination
scalar OnChainAddress

union SettlementVia =
    SettlementViaIntraLedger
  | SettlementViaLn
  | SettlementViaOnChain

type SettlementViaIntraLedger {
  counterPartyWalletId: WalletId

  # Settlement destination: Could be null if the payee does not have a username
  counterPartyUsername: Username
}

type SettlementViaLn {
  paymentSecret: LnPaymentSecret
    @deprecated(
      reason: "Shifting property to 'preImage' to improve granularity of the LnPaymentSecret type"
    )
  preImage: LnPaymentPreImage
}

scalar LnPaymentSecret

scalar LnPaymentPreImage

type SettlementViaOnChain {
  transactionHash: OnChainTxHash!
  vout: Int
}

scalar OnChainTxHash

# Price of 1 sat or 1 usd cent in base/offset. To calculate, use: `base / 10^offset`
type PriceOfOneSettlementMinorUnitInDisplayMinorUnit implements PriceInterface {
  base: SafeInt!
  offset: Int!
  currencyUnit: String! @deprecated(reason: "Deprecated due to type renaming")
  formattedAmount: String!
    @deprecated(reason: "Deprecated please use `base / 10^offset`")
}

interface PriceInterface {
  base: SafeInt!
  offset: Int!
  currencyUnit: String! @deprecated(reason: "Deprecated due to type renaming")
}

# Non-fractional signed whole numeric value between -(2^53) + 1 and 2^53 - 1
scalar SafeInt

# A string amount (of a currency) that can be negative (e.g. in a transaction)
scalar SignedDisplayMajorAmount

# Display currency of an account
scalar DisplayCurrency

enum TxDirection {
  SEND
  RECEIVE
}

enum TxStatus {
  PENDING
  SUCCESS
  FAILURE
}

# Text field in a lightning payment transaction
scalar Memo

# Timestamp field, serialized as Unix time (the number of seconds since the Unix epoch)
scalar Timestamp

enum AccountLevel {
  ONE
  TWO
}

type RealtimePrice {
  id: ID!

  # Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC)
  timestamp: Timestamp!
  denominatorCurrency: DisplayCurrency!
  btcSatPrice: PriceOfOneSatInMinorUnit!
  usdCentPrice: PriceOfOneUsdCentInMinorUnit!
}

# Price of 1 sat in base/offset. To calculate, use: `base / 10^offset`
type PriceOfOneSatInMinorUnit implements PriceInterface {
  base: SafeInt!
  offset: Int!
  currencyUnit: String! @deprecated(reason: "Deprecated due to type renaming")
}

# Price of 1 usd cent in base/offset. To calculate, use: `base / 10^offset`
type PriceOfOneUsdCentInMinorUnit implements PriceInterface {
  base: SafeInt!
  offset: Int!
  currencyUnit: String! @deprecated(reason: "Deprecated due to type renaming")
}

type AccountLimits {
  # Limits for withdrawing to external onchain or lightning destinations.
  withdrawal: [AccountLimit!]!

  # Limits for sending to other internal accounts.
  internalSend: [AccountLimit!]!

  # Limits for converting between currencies among a account's own wallets.
  convert: [AccountLimit!]!
}

interface AccountLimit {
  # The current maximum limit for a given 24 hour period.
  totalLimit: CentAmount!

  # The amount of cents remaining below the limit for the current 24 hour period.
  remainingLimit: CentAmount

  # The rolling time interval in seconds that the limits would apply for.
  interval: Seconds
}

# (Positive) Cent amount (1/100 of a dollar)
scalar CentAmount

# (Positive) amount of seconds
scalar Seconds

type Quiz {
  id: ID!

  # The reward in Satoshis for the quiz question
  amount: SatAmount!
  completed: Boolean!
}

# (Positive) Satoshi amount
scalar SatAmount

# A wallet belonging to an account which contains a BTC balance and a list of transactions.
type BTCWallet implements Wallet {
  id: ID!
  accountId: ID!
  walletCurrency: WalletCurrency!

  # A balance stored in BTC.
  balance: SignedAmount!

  # An unconfirmed incoming onchain balance.
  pendingIncomingBalance: SignedAmount!

  # A list of BTC transactions associated with this wallet.
  transactions(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the first n items from the list.
    first: Int

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the last n items from the list.
    last: Int
  ): TransactionConnection
  transactionsByAddress(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the first n items from the list.
    first: Int

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the last n items from the list.
    last: Int

    # Returns the items that include this address.
    address: OnChainAddress!
  ): TransactionConnection
}

# A wallet belonging to an account which contains a USD balance and a list of transactions.
type UsdWallet implements Wallet {
  id: ID!
  accountId: ID!
  walletCurrency: WalletCurrency!
  balance: SignedAmount!

  # An unconfirmed incoming onchain balance.
  pendingIncomingBalance: SignedAmount!
  transactions(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the first n items from the list.
    first: Int

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the last n items from the list.
    last: Int
  ): TransactionConnection
  transactionsByAddress(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the first n items from the list.
    first: Int

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the last n items from the list.
    last: Int

    # Returns the items that include this address.
    address: OnChainAddress!
  ): TransactionConnection
}

type OneDayAccountLimit implements AccountLimit {
  # The current maximum limit for a given 24 hour period.
  totalLimit: CentAmount!

  # The amount of cents remaining below the limit for the current 24 hour period.
  remainingLimit: CentAmount

  # The rolling time interval value in seconds for the current 24 hour period.
  interval: Seconds
}

type Query {
  globals: Globals
  usernameAvailable(username: Username!): Boolean
  userDefaultWalletId(username: Username!): WalletId!
    @deprecated(reason: "will be migrated to AccountDefaultWalletId")
  accountDefaultWallet(
    username: Username!
    walletCurrency: WalletCurrency
  ): PublicWallet!
  businessMapMarkers: [MapMarker]
  currencyList: [Currency!]!
  mobileVersions: [MobileVersions]
  quizQuestions: [QuizQuestion]
    @deprecated(
      reason: "TODO: remove. we don't need a non authenticated version of this query. the users can only do the query while authenticated"
    )
  btcPrice(currency: DisplayCurrency! = "USD"): Price
    @deprecated(reason: "Deprecated in favor of realtimePrice")

  # Returns 1 Sat and 1 Usd Cent price for the given currency
  realtimePrice(currency: DisplayCurrency = "USD"): RealtimePrice!
  btcPriceList(range: PriceGraphRange!): [PricePoint]
  lnInvoicePaymentStatus(
    input: LnInvoicePaymentStatusInput!
  ): LnInvoicePaymentStatusPayload!
  me: User
  onChainTxFee(
    walletId: WalletId!
    address: OnChainAddress!
    amount: SatAmount!
    targetConfirmations: TargetConfirmations = 1
  ): OnChainTxFee!
  onChainUsdTxFee(
    walletId: WalletId!
    address: OnChainAddress!
    amount: CentAmount!
    targetConfirmations: TargetConfirmations = 1
  ): OnChainUsdTxFee!
  onChainUsdTxFeeAsBtcDenominated(
    walletId: WalletId!
    address: OnChainAddress!
    amount: SatAmount!
    targetConfirmations: TargetConfirmations = 1
  ): OnChainUsdTxFee!
}

# Provides global settings for the application which might have an impact for the user.
type Globals {
  # A list of public keys for the running lightning nodes.
  # This can be used to know if an invoice belongs to one of our nodes.
  nodesIds: [String!]!

  # Which network (mainnet, testnet, regtest, signet) this instance is running on.
  network: Network!
  buildInformation: BuildInformation!

  # The domain name for lightning addresses accepted by this Galoy instance
  lightningAddressDomain: String!
  lightningAddressDomainAliases: [String!]!
}

enum Network {
  mainnet
  testnet
  signet
  regtest
}

type BuildInformation {
  commitHash: String
  buildTime: Timestamp
  helmRevision: Int
}

# A public view of a generic wallet which stores value in one of our supported currencies.
type PublicWallet {
  id: ID!
  walletCurrency: WalletCurrency!
}

type MapMarker {
  username: Username
  mapInfo: MapInfo!
}

type MapInfo {
  title: String!
  coordinates: Coordinates!
}

type Coordinates {
  longitude: Float!
  latitude: Float!
}

type Currency {
  id: ID!
  symbol: String!
  name: String!
  flag: String!
  fractionDigits: Int!
}

type MobileVersions {
  platform: String!
  currentSupported: Int!
  minSupported: Int!
}

type QuizQuestion {
  id: ID!

  # The earn reward in Satoshis for the quiz question
  earnAmount: SatAmount!
}

# Price amount expressed in base/offset. To calculate, use: `base / 10^offset`
type Price {
  base: SafeInt!
  offset: Int!
  currencyUnit: String!
  formattedAmount: String!
}

type PricePoint {
  # Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC)
  timestamp: Timestamp!
  price: Price!
}

# The range for the X axis in the BTC price graph
enum PriceGraphRange {
  ONE_DAY
  ONE_WEEK
  ONE_MONTH
  ONE_YEAR
  FIVE_YEARS
}

type LnInvoicePaymentStatusPayload {
  errors: [Error!]!
  status: InvoicePaymentStatus
}

enum InvoicePaymentStatus {
  PENDING
  PAID
  EXPIRED
}

input LnInvoicePaymentStatusInput {
  paymentRequest: LnPaymentRequest!
}

# BOLT11 lightning invoice payment request with the amount included
scalar LnPaymentRequest

type User {
  id: ID!

  # Phone number with international calling code.
  phone: Phone

  # Optional immutable user friendly identifier.
  username: Username
    @deprecated(reason: "will be moved to @Handle in Account and Wallet")

  # Preferred language for user.
  # When value is 'default' the intent is to use preferred language from OS settings.
  language: Language!

  # List the quiz questions the user may have completed.
  quizQuestions: [UserQuizQuestion!]!
    @deprecated(reason: "use Quiz from Account instead")

  # Get full list of contacts.
  # Can include the transactions associated with each contact.
  contacts: [UserContact!]! @deprecated(reason: "will be moved to account")

  # Get single contact details.
  # Can include the transactions associated with the contact.
  contactByUsername(username: Username!): UserContact!
    @deprecated(reason: "will be moved to Accounts")
  createdAt: Timestamp!
  defaultAccount: Account!
}

# Phone number which includes country code
scalar Phone

scalar Language

type UserQuizQuestion {
  question: QuizQuestion!
  completed: Boolean!
}

type UserContact {
  id: Username!

  # Actual identifier of the contact.
  username: Username!

  # Alias the user can set for this contact.
  # Only the user can see the alias attached to their contact.
  alias: ContactAlias
  transactionsCount: Int!

  # Paginated list of transactions sent to/from this contact.
  transactions(
    # Returns the items in the list that come after the specified cursor.
    after: String

    # Returns the first n items from the list.
    first: Int

    # Returns the items in the list that come before the specified cursor.
    before: String

    # Returns the last n items from the list.
    last: Int
  ): TransactionConnection
}

# An alias name that a user can set for a wallet (with which they have transactions)
scalar ContactAlias

type OnChainTxFee {
  amount: SatAmount!
  targetConfirmations: TargetConfirmations!
}

# (Positive) Number of blocks in which the transaction is expected to be confirmed
scalar TargetConfirmations

type OnChainUsdTxFee {
  amount: CentAmount!
  targetConfirmations: TargetConfirmations!
}

type Mutation {
  userRequestAuthCode(input: UserRequestAuthCodeInput!): SuccessPayload!
  userLogin(input: UserLoginInput!): AuthTokenPayload!
  userLogout(input: UserLogoutInput!): AuthTokenPayload!
  captchaCreateChallenge: CaptchaCreateChallengePayload!
  captchaRequestAuthCode(input: CaptchaRequestAuthCodeInput!): SuccessPayload!

  # Returns a lightning invoice for an associated wallet.
  # When invoice is paid the value will be credited to a BTC wallet.
  # Expires after 24 hours.
  lnInvoiceCreateOnBehalfOfRecipient(
    input: LnInvoiceCreateOnBehalfOfRecipientInput!
  ): LnInvoicePayload!

  # Returns a lightning invoice denominated in satoshis for an associated wallet.
  # When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
  # Expires after 5 minutes (short expiry time because there is a USD/BTC exchange rate
  #   associated with the amount).
  lnUsdInvoiceCreateOnBehalfOfRecipient(
    input: LnUsdInvoiceCreateOnBehalfOfRecipientInput!
  ): LnInvoicePayload!

  # Returns a lightning invoice for an associated wallet.
  # Can be used to receive any supported currency value (currently USD or BTC).
  # Expires after 24 hours.
  lnNoAmountInvoiceCreateOnBehalfOfRecipient(
    input: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput!
  ): LnNoAmountInvoicePayload!
  userQuizQuestionUpdateCompleted(
    input: UserQuizQuestionUpdateCompletedInput!
  ): UserQuizQuestionUpdateCompletedPayload!
    @deprecated(reason: "Use QuizCompletedMutation instead")
  quizCompleted(input: QuizCompletedInput!): QuizCompletedPayload!
  deviceNotificationTokenCreate(
    input: DeviceNotificationTokenCreateInput!
  ): SuccessPayload!
  userUpdateLanguage(
    input: UserUpdateLanguageInput!
  ): UserUpdateLanguagePayload!
  userUpdateUsername(
    input: UserUpdateUsernameInput!
  ): UserUpdateUsernamePayload!
  accountUpdateDefaultWalletId(
    input: AccountUpdateDefaultWalletIdInput!
  ): AccountUpdateDefaultWalletIdPayload!
  accountUpdateDisplayCurrency(
    input: AccountUpdateDisplayCurrencyInput!
  ): AccountUpdateDisplayCurrencyPayload!
  userContactUpdateAlias(
    input: UserContactUpdateAliasInput!
  ): UserContactUpdateAliasPayload!
    @deprecated(reason: "will be moved to AccountContact")

  # Actions a payment which is internal to the ledger e.g. it does
  # not use onchain/lightning. Returns payment status (success,
  # failed, pending, already_paid).
  intraLedgerPaymentSend(
    input: IntraLedgerPaymentSendInput!
  ): PaymentSendPayload!

  # Actions a payment which is internal to the ledger e.g. it does
  # not use onchain/lightning. Returns payment status (success,
  # failed, pending, already_paid).
  intraLedgerUsdPaymentSend(
    input: IntraLedgerUsdPaymentSendInput!
  ): PaymentSendPayload!
  lnInvoiceFeeProbe(input: LnInvoiceFeeProbeInput!): SatAmountPayload!
  lnUsdInvoiceFeeProbe(input: LnUsdInvoiceFeeProbeInput!): SatAmountPayload!
  lnNoAmountInvoiceFeeProbe(
    input: LnNoAmountInvoiceFeeProbeInput!
  ): SatAmountPayload!
  lnNoAmountUsdInvoiceFeeProbe(
    input: LnNoAmountUsdInvoiceFeeProbeInput!
  ): CentAmountPayload!

  # Returns a lightning invoice for an associated wallet.
  # When invoice is paid the value will be credited to a BTC wallet.
  # Expires after 24 hours.
  lnInvoiceCreate(input: LnInvoiceCreateInput!): LnInvoicePayload!

  # Returns a lightning invoice denominated in satoshis for an associated wallet.
  # When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
  # Expires after 5 minutes (short expiry time because there is a USD/BTC exchange rate
  # associated with the amount).
  lnUsdInvoiceCreate(input: LnUsdInvoiceCreateInput!): LnInvoicePayload!

  # Returns a lightning invoice for an associated wallet.
  # Can be used to receive any supported currency value (currently USD or BTC).
  # Expires after 24 hours.
  lnNoAmountInvoiceCreate(
    input: LnNoAmountInvoiceCreateInput!
  ): LnNoAmountInvoicePayload!

  # Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
  # Provided wallet can be USD or BTC and must have sufficient balance to cover amount in lightning invoice.
  # Returns payment status (success, failed, pending, already_paid).
  lnInvoicePaymentSend(input: LnInvoicePaymentInput!): PaymentSendPayload!

  # Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
  # Provided wallet must be BTC and must have sufficient balance to cover amount specified in mutation request.
  # Returns payment status (success, failed, pending, already_paid).
  lnNoAmountInvoicePaymentSend(
    input: LnNoAmountInvoicePaymentInput!
  ): PaymentSendPayload!

  # Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
  # Provided wallet must be USD and have sufficient balance to cover amount specified in mutation request.
  # Returns payment status (success, failed, pending, already_paid).
  lnNoAmountUsdInvoicePaymentSend(
    input: LnNoAmountUsdInvoicePaymentInput!
  ): PaymentSendPayload!
  onChainAddressCreate(
    input: OnChainAddressCreateInput!
  ): OnChainAddressPayload!
  onChainAddressCurrent(
    input: OnChainAddressCurrentInput!
  ): OnChainAddressPayload!
  onChainPaymentSend(input: OnChainPaymentSendInput!): PaymentSendPayload!
  onChainUsdPaymentSend(input: OnChainUsdPaymentSendInput!): PaymentSendPayload!
  onChainUsdPaymentSendAsBtcDenominated(
    input: OnChainUsdPaymentSendAsBtcDenominatedInput!
  ): PaymentSendPayload!
  onChainPaymentSendAll(input: OnChainPaymentSendAllInput!): PaymentSendPayload!
}

type SuccessPayload {
  errors: [Error!]!
  success: Boolean
}

input UserRequestAuthCodeInput {
  phone: Phone!
  channel: PhoneCodeChannelType
}

enum PhoneCodeChannelType {
  SMS
  WHATSAPP
}

type AuthTokenPayload {
  errors: [Error!]!
  authToken: AuthToken
}

# An Opaque Bearer token
scalar AuthToken

input UserLoginInput {
  phone: Phone!
  code: OneTimeAuthCode!
}

# An authentication code valid for a single use
scalar OneTimeAuthCode

input UserLogoutInput {
  authToken: AuthToken!
}

type CaptchaCreateChallengePayload {
  errors: [Error!]!
  result: CaptchaCreateChallengeResult
}

type CaptchaCreateChallengeResult {
  id: String!
  challengeCode: String!
  newCaptcha: Boolean!
  failbackMode: Boolean!
}

input CaptchaRequestAuthCodeInput {
  phone: Phone!
  challengeCode: String!
  validationCode: String!
  secCode: String!
  channel: PhoneCodeChannelType
}

type LnInvoicePayload {
  errors: [Error!]!
  invoice: LnInvoice
}

type LnInvoice {
  paymentRequest: LnPaymentRequest!
  paymentHash: PaymentHash!
  paymentSecret: LnPaymentSecret!
  satoshis: SatAmount
}

input LnInvoiceCreateOnBehalfOfRecipientInput {
  # Wallet ID for a BTC wallet which belongs to any account.
  recipientWalletId: WalletId!

  # Amount in satoshis.
  amount: SatAmount!

  # Optional memo for the lightning invoice.
  memo: Memo
  descriptionHash: Hex32Bytes
}

# Hex-encoded string of 32 bytes
scalar Hex32Bytes

input LnUsdInvoiceCreateOnBehalfOfRecipientInput {
  # Wallet ID for a USD wallet which belongs to the account of any user.
  recipientWalletId: WalletId!

  # Amount in USD cents.
  amount: CentAmount!

  # Optional memo for the lightning invoice. Acts as a note to the recipient.
  memo: Memo
  descriptionHash: Hex32Bytes
}

type LnNoAmountInvoicePayload {
  errors: [Error!]!
  invoice: LnNoAmountInvoice
}

type LnNoAmountInvoice {
  paymentRequest: LnPaymentRequest!
  paymentHash: PaymentHash!
  paymentSecret: LnPaymentSecret!
}

input LnNoAmountInvoiceCreateOnBehalfOfRecipientInput {
  # ID for either a USD or BTC wallet which belongs to the account of any user.
  recipientWalletId: WalletId!

  # Optional memo for the lightning invoice.
  memo: Memo
}

type UserQuizQuestionUpdateCompletedPayload {
  errors: [Error!]!
  userQuizQuestion: UserQuizQuestion
}

input UserQuizQuestionUpdateCompletedInput {
  id: ID!
}

type QuizCompletedPayload {
  errors: [Error!]!
  quiz: Quiz
}

input QuizCompletedInput {
  id: ID!
}

input DeviceNotificationTokenCreateInput {
  deviceToken: String!
}

type UserUpdateLanguagePayload {
  errors: [Error!]!
  user: User
}

input UserUpdateLanguageInput {
  language: Language!
}

type UserUpdateUsernamePayload {
  errors: [Error!]!
  user: User
}

input UserUpdateUsernameInput {
  username: Username!
}

type AccountUpdateDefaultWalletIdPayload {
  errors: [Error!]!
  account: ConsumerAccount
}

input AccountUpdateDefaultWalletIdInput {
  walletId: WalletId!
}

type AccountUpdateDisplayCurrencyPayload {
  errors: [Error!]!
  account: ConsumerAccount
}

input AccountUpdateDisplayCurrencyInput {
  currency: DisplayCurrency!
}

type UserContactUpdateAliasPayload {
  errors: [Error!]!
  contact: UserContact
}

input UserContactUpdateAliasInput {
  username: Username!
  alias: ContactAlias!
}

type PaymentSendPayload {
  errors: [Error!]!
  status: PaymentSendResult
}

enum PaymentSendResult {
  SUCCESS
  FAILURE
  PENDING
  ALREADY_PAID
}

input IntraLedgerPaymentSendInput {
  # The wallet ID of the sender.
  walletId: WalletId!
  recipientWalletId: WalletId!

  # Amount in satoshis.
  amount: SatAmount!

  # Optional memo to be attached to the payment.
  memo: Memo
}

input IntraLedgerUsdPaymentSendInput {
  # The wallet ID of the sender.
  walletId: WalletId!
  recipientWalletId: WalletId!

  # Amount in cents.
  amount: CentAmount!

  # Optional memo to be attached to the payment.
  memo: Memo
}

type SatAmountPayload {
  errors: [Error!]!
  amount: SatAmount
}

input LnInvoiceFeeProbeInput {
  walletId: WalletId!
  paymentRequest: LnPaymentRequest!
}

input LnUsdInvoiceFeeProbeInput {
  walletId: WalletId!
  paymentRequest: LnPaymentRequest!
}

input LnNoAmountInvoiceFeeProbeInput {
  walletId: WalletId!
  paymentRequest: LnPaymentRequest!
  amount: SatAmount!
}

type CentAmountPayload {
  errors: [Error!]!
  amount: CentAmount
}

input LnNoAmountUsdInvoiceFeeProbeInput {
  walletId: WalletId!
  paymentRequest: LnPaymentRequest!
  amount: CentAmount!
}

input LnInvoiceCreateInput {
  # Wallet ID for a BTC wallet belonging to the current account.
  walletId: WalletId!

  # Amount in satoshis.
  amount: SatAmount!

  # Optional memo for the lightning invoice.
  memo: Memo
}

input LnUsdInvoiceCreateInput {
  # Wallet ID for a USD wallet belonging to the current user.
  walletId: WalletId!

  # Amount in USD cents.
  amount: CentAmount!

  # Optional memo for the lightning invoice.
  memo: Memo
}

input LnNoAmountInvoiceCreateInput {
  # ID for either a USD or BTC wallet belonging to the account of the current user.
  walletId: WalletId!

  # Optional memo for the lightning invoice.
  memo: Memo
}

input LnInvoicePaymentInput {
  # Wallet ID with sufficient balance to cover amount of invoice.  Must belong to the account of the current user.
  walletId: WalletId!

  # Payment request representing the invoice which is being paid.
  paymentRequest: LnPaymentRequest!

  # Optional memo to associate with the lightning invoice.
  memo: Memo
}

input LnNoAmountInvoicePaymentInput {
  # Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user.
  walletId: WalletId!

  # Payment request representing the invoice which is being paid.
  paymentRequest: LnPaymentRequest!

  # Amount to pay in satoshis.
  amount: SatAmount!

  # Optional memo to associate with the lightning invoice.
  memo: Memo
}

input LnNoAmountUsdInvoicePaymentInput {
  # Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user.
  walletId: WalletId!

  # Payment request representing the invoice which is being paid.
  paymentRequest: LnPaymentRequest!

  # Amount to pay in USD cents.
  amount: CentAmount!

  # Optional memo to associate with the lightning invoice.
  memo: Memo
}

type OnChainAddressPayload {
  errors: [Error!]!
  address: OnChainAddress
}

input OnChainAddressCreateInput {
  walletId: WalletId!
}

input OnChainAddressCurrentInput {
  walletId: WalletId!
}

input OnChainPaymentSendInput {
  walletId: WalletId!
  address: OnChainAddress!
  amount: SatAmount!
  memo: Memo
  targetConfirmations: TargetConfirmations = 1
}

input OnChainUsdPaymentSendInput {
  walletId: WalletId!
  address: OnChainAddress!
  amount: CentAmount!
  memo: Memo
  targetConfirmations: TargetConfirmations = 1
}

input OnChainUsdPaymentSendAsBtcDenominatedInput {
  walletId: WalletId!
  address: OnChainAddress!
  amount: SatAmount!
  memo: Memo
  targetConfirmations: TargetConfirmations = 1
}

input OnChainPaymentSendAllInput {
  walletId: WalletId!
  address: OnChainAddress!
  memo: Memo
  targetConfirmations: TargetConfirmations = 1
}

type Subscription {
  myUpdates: MyUpdatesPayload!
  price(input: PriceInput!): PricePayload!

  # Returns the price of 1 satoshi
  realtimePrice(input: RealtimePriceInput!): RealtimePricePayload!
  lnInvoicePaymentStatus(
    input: LnInvoicePaymentStatusInput!
  ): LnInvoicePaymentStatusPayload!
}

type MyUpdatesPayload {
  errors: [Error!]!
  update: UserUpdate
  me: User
}

union UserUpdate =
    RealtimePrice
  | Price
  | LnUpdate
  | OnChainUpdate
  | IntraLedgerUpdate

type LnUpdate {
  paymentHash: PaymentHash!
  status: InvoicePaymentStatus!
  walletId: WalletId!
}

type OnChainUpdate {
  txNotificationType: TxNotificationType!
  txHash: OnChainTxHash!
  amount: SatAmount!
  displayCurrencyPerSat: Float!
  usdPerSat: Float! @deprecated(reason: "updated over displayCurrencyPerSat")
  walletId: WalletId!
}

enum TxNotificationType {
  OnchainReceipt
  OnchainReceiptPending
  OnchainPayment
  LnInvoicePaid
  IntraLedgerReceipt
  IntraLedgerPayment
}

type IntraLedgerUpdate {
  txNotificationType: TxNotificationType!
  amount: SatAmount!
  displayCurrencyPerSat: Float!
  usdPerSat: Float! @deprecated(reason: "updated over displayCurrencyPerSat")
  walletId: WalletId!
}

type PricePayload {
  errors: [Error!]!
  price: Price
}

input PriceInput {
  amount: SatAmount!
  amountCurrencyUnit: ExchangeCurrencyUnit!
  priceCurrencyUnit: ExchangeCurrencyUnit!
}

enum ExchangeCurrencyUnit {
  BTCSAT
  USDCENT
}

type RealtimePricePayload {
  errors: [Error!]!
  realtimePrice: RealtimePrice
}

input RealtimePriceInput {
  currency: DisplayCurrency = "USD"
}
